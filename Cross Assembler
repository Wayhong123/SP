# include<fstream>
# include<string.h>
# include<iostream>
# include <cctype>
# include<stdlib.h>
# include<cstdlib>
# include<cstring>
# include<cctype>
# include<algorithm>
# include<sstream>
# include<vector>
# include<iomanip>
using namespace std;

typedef enum { Space = -1, Remark, Special, String, Other, Newline, Number,Hex
} CutType; // 字元的類型

typedef enum { format1 = 1, format2, format3, format4
}length;

class Converter {
	public:		
		string itos( int num ) {
			stringstream ss;
			ss << num;
			string str = ss.str();
			ss.str("");
			ss.clear();
			return str;
		}
		
		int Convert_Dec( string str ) { // 16進位轉換成10進位 
			int num;
			istringstream( str ) >> hex >> num;
			return num;
		}
		
		string itos_format( int radix, string str ) {
			char ch[str.size()];
			int num = atoi(str.c_str());
			itoa( num, ch, radix );
			string result;
			int i = 0;
			result = ch;
			transform(result.begin(), result.end(), result.begin(), ::toupper);
			return result;
		}

		string itoc_format( int radix, char ch ) {
			int num = ch;
			char ch2[2];
			itoa( num, ch2, radix );
			string str = ch2;
			return str;
		}
};

class Cutter {
public:
	CutType Cut( char ch ) { // 回傳字元的類型 
		if ( ( ch == 32 || ch == 9 || ch == 10 ) ) {
			if ( ch == 10 ) {
				return Newline;
			}
			
			return Space;
		}
		
		else if ( ch == 35 || ch == 39 || ( ch >= 42 && ch <= 47) ||
		          ch == 58 || ch == 59 || ch == 61 || ch == 63 || ch == 64 ) {
			
			if ( ch == 46 ) {
				return Remark;	
			}
			
			else {
				return Special;
			}
		}
		
		else if ( ch >= 48 & ch <= 57 ) {
			return Number;
		}
		
		else {
			return Other;
		}		
	}
};

class Table {
private:
	fstream file;
	Cutter cutter;
	Converter convert;
	vector< vector<string> > base_table; // Table1~Table4 
	typedef struct tb {
		string str; // 名稱 
		int value; //  位置 
	}table;
	
	typedef struct symTb {
		string str; // 名稱
		int value;
		string address; // 地址
	}symbolTb;
	
	typedef struct op {
		string str; // 名稱 
		string format; // 格式 
		string opcode;  
	}opTb;
	
	struct ascending { // 升序
    	inline bool operator() (const table& struct1, const table& struct2) {
     		return (struct1.value < struct2.value);
    	}
	};
	
	vector<table> num_table; // 數字表格
	vector<symbolTb>sym_table; // 標籤表格含地址 
	vector<table> symbol_table; // 標籤表格 
	vector<table> string_table;  // 字串表格
	vector<op> opcode_table; // OPTAB
public:
	void Bulid_base_table() { // 建立表格 
		stringstream ss;
		for ( int i = 1 ; i <= 4 ; i++ ) {
			ss << i;
			string num = ss.str();
			string filename = "Table" + num + ".table";
			file.open( filename.c_str(), ios::in );
			if ( !file.fail() ) {
				string line;
				vector<string> record;
				while ( !file.eof() && getline( file, line ) ) {
					line.erase(line.find_last_not_of(' ')+1);
					record.push_back( line );
				}
				
				base_table.push_back( record );
				record.clear();
				file.close();
				ss.str("");
				ss.clear();
			}
			
			else {
				cout << filename << " 不存在!!!";
			} 
		}
	}
	
	void Bulid_opcode_table() {
		string name = "OPTABLE.txt";
		file.open(name.c_str(), ios::in );
		if ( file.fail() ) {
			cout << "OPTABLE.txt讀入失敗!!!" << endl << endl;
		}
		
		else {
			string str;
			string temp, cut;
			opTb findOP;
			int num = 0;
			while ( getline(file,str) && !file.eof() ) {
				int pos = str.find_first_of(" ");
				int pre = 0;
				findOP.str = str.substr(pre,pos-pre);
				pre = pos + 1;
				pos = str.find_last_of(" ");
				findOP.format = str.substr(pre,pos-pre);
				pre = pos + 1;
				pos = str.find('\n',1);
				findOP.opcode = str.substr(pre,pos-pre);
				opcode_table.push_back(findOP);
			}
			
			file.close();
		}
	}
	
	string Get_opcode( string str ) {
		bool find = false;
		for ( int i = 0 ; i < opcode_table.size() ; i++ ) {
			if ( Compare_Instr( str, opcode_table[i].str) ) {
				find = true;
				return opcode_table[i].opcode;
			}
		}
		
		if ( !find ) {
			return "NO";
		}
	}
	
	bool Exist_In_sym_table( string str ) { // 重複標籤 
		for ( int i = 0 ; i < sym_table.size() ; i++ ) {
			if ( Compare_Instr( sym_table[i].str, str) ) {
				return true;
			}
		}
		
		return false;
	}
	
	string Get_Address( string str ) {
		for ( int i = 0 ; i < sym_table.size() ; i++ ) {
			if ( Compare_Instr( sym_table[i].str, str) ) {
				return sym_table[i].address;
			}
		}	
	}
	
	void Set_sym_table( int valueOfTable, string address, string str ) {
		symTb temp;
		temp.str = str;
		temp.address = address;
		temp.value = valueOfTable;
		if ( sym_table.size() == 0 ) {
			sym_table.push_back(temp);
		}
		
		else {
			for ( int i = 0 ; i < sym_table.size() ; i++ ) {
				if ( sym_table[i].value == temp.value ) {
					temp.value++;
					if ( temp.value > 99 ) {
						temp.value = 0;
						i = -1;
					}
				}
			}
			
			sym_table.push_back(temp);
		}
	}
	
	void Show() {
		for ( int i = 0 ; i < sym_table.size() ; i++ ) {
			if ( sym_table[i].str.size() != 0 )
				cout << sym_table[i].str << "\t" << sym_table[i].address << endl;
		}
	}
	
	void Relocation( int pc ) {
		for ( int i = 0 ; i < sym_table.size() ; i++ ) {
			if ( sym_table[i].str.size() != 0 ) {
				int newadr = atoi(sym_table[i].address.c_str());
				newadr = newadr + pc;
				sym_table[i].address = convert.itos(newadr);
			}
			
			else {
				break;
			}
		}	
	}
	
	bool Compare_Instr( string str, string str2 ) { // 比較是否為相同指令 
		transform(str.begin(),str.end(),str.begin(), ::toupper);
		transform(str2.begin(),str2.end(),str2.begin(), ::toupper);		
		if ( str == str2 ) {
			return true;
		}
		
		else {
			return false;
		}
	}
	
	// 將詞塊放到表格上，可能發生衝突  
	void SetInTable( int & num, vector<table> & goal, string find ) {
		if ( goal.size() != 0 ) {
			for ( int i = 0 ; i < goal.size() ; i++ ) {
				if ( find == goal[i].str ) { // 找到對應的詞塊 
					break;
				}
				
				else if ( num == goal[i].value ) { // 發生衝突 
					num++;
					if ( num > 99 ) { // 超出範圍，從表格開頭開始找起 
						num = 0;
						i = -1;
					}
				}
			}
		}
		
		table t;
		t.str = find;
		t.value = num;
		goal.push_back( t );
		sort( goal.begin(), goal.end(), ascending() ); // 表格排序 
	}
	
	// 找到詞塊對應表格的位置 
	void Find_Token( string goal, int & numOftable, int & valueOftable, CutType status ) {
		bool iSfind = false;
		// 先從Table1~Table4開始尋找對應的詞塊 //
		if ( status != String && status != Hex ) {
			for ( int i = 0 ; i < base_table.size() && !iSfind ; i++ ) {
				for ( int j = 0 ; j < base_table[i].size() ; j++ ) {
					if ( Compare_Instr( goal, base_table[i][j] ) ) {
						numOftable = i+1;
						valueOftable = j+1;
						iSfind = true;
						break;
					}
				}
			}
		}
		
		if ( !iSfind ) {  // 詞塊不在Table1~Table4 
			int total = 0;
			for ( int i = 0 ; i < goal.size() ; i++ ) {
				total = total + goal[i];
			}
			
			total = total % 100;
			CutType cutType = cutter.Cut( goal[0] ); // 取得詞塊第一個字元的類型 
			if ( ( cutType == Number || status == Hex ) && status != String ) { // 數字 
				SetInTable( total, num_table, goal );
				numOftable = 6;
			}
			
			else if ( status == String ) { // 字串 
				SetInTable( total, string_table, goal );
				numOftable = 7;
			}
			
			else { // 標籤 
				SetInTable( total, symbol_table, goal );
				numOftable = 5;
			}
			
			valueOftable = total;
		}
	}
	 
	void Clear() { // 初始化 
		for ( int i = 0 ; i < base_table.size() ; i++ ) {
			for ( int j = 0 ; j < base_table[i].size() ; j++ ) {
				base_table[j].clear(); 
			}
			
			base_table[i].clear();
		}
		
		base_table.clear();		
		num_table.clear();		
		symbol_table.clear();
		sym_table.clear();	
		string_table.clear();
	}
	
};

class Assembler {
private:
	
	typedef struct tR {
		string str; // 名稱 
		int numOftable; // 所在的表格 
		int valueOftable; // 所在的表格位置 
		int line; // column in sourcecode 
	}tokenRecord;
	
	typedef struct sR {
		string str; // 原始程式碼 
		string address; // 地址 
		string machine_code; // 機器碼 
	}sourceRecord;
	
	fstream file;
	string filename;
	Converter convert;
	int pc; // 程式計數器 
	Cutter cutter; // 字元處理
	Table table; // 表格
	vector<sourceRecord> source; // 原始程式碼
	vector<tokenRecord> token_record; // 紀錄詞塊
	
public:
	
	Assembler() {
		pc = 0;
	}
	
	string Get_Machine_Code( string opcode, string x, string addr ) {
		string result;
		addr = convert.itos_format(16,addr);
		if ( addr == "0" ) {
			addr = "0000";
		}
		
		result = result + opcode;
		if ( x != "1" ) {
			int num = 6 - addr.size();
			if ( num == 4 ) {
				return result + addr;
			}
			
			else {
				string mid;
				num = 6 - result.size() - addr.size();
				for ( int i = 0 ; i < num ; i++ ) {
					mid = mid + "0";
				}
				
				return result + mid + addr;
			}
		}
		
		else {
			int num = atoi( addr.c_str() );
			num = num + 8000;
			stringstream ss;
			ss << num;
			string back = ss.str();
			result = result + back;
			ss.str("");
			ss.clear();
			return result;
		}
	}
	
	void Setfilename( string name ) { // 檔案名稱 
		filename = name;	
	}
	
	// 紀錄新的詞塊 // 
	void Push_in_token_record( string & temp, int line, CutType status ) {  
		tokenRecord token;
		token.str = temp;
		token.line = line;
		table.Find_Token(temp,token.numOftable,token.valueOftable,status);
		token_record.push_back(token);
		temp.clear();
	}
	
	// 紀錄一個或兩個詞塊 // 
	void GetToken( string & temp, int line, CutType & status, char nextChar ) {
		if ( temp.size() == 0 ) { // 一個詞塊
			temp = temp + nextChar;
			Push_in_token_record( temp,line, status );
		}
		
		else { // 兩個詞塊
			Push_in_token_record( temp,line, status );
			temp = temp + nextChar;
			if ( status == String || status == Hex ) {
				status = Other;	
			}
			Push_in_token_record( temp,line, status );
		}
	}
	
	bool Lexical_Analysis( string filename ) { // 語彙分析 
		file.open(filename.c_str(), ios::in );
		if ( !file.fail() ) {
			char nextChar = '\0';
			string temp;
			sourceRecord sourceOfLine;
			sourceOfLine.address = "-1";
			sourceOfLine.machine_code = "-1";
			table.Bulid_base_table();
			int charnum = 0,line = 0;
			CutType status = Other;
			while ( file.get(nextChar) ) {
				CutType cut_type = cutter.Cut( nextChar );
				// 空格或換行
				if ( ( cut_type == Space || cut_type == Newline ) && ( status == Other )) {
					if ( temp.size() != 0 ) {
						Push_in_token_record( temp,line, status );
					}
				}
				
				else if ( cut_type == Remark && status == Other ) { // 註解 
					GetToken( temp, line, status, nextChar );
					status = Remark;
				}
				
				// 特殊符號 && 字串 && 十六進位 
				else if ( ( cut_type == Special && status == Other) ||
						  ( nextChar == 39 && charnum == 1 ) ) {
					string front;
					if ( nextChar == 39 ) {
						if ( ( temp == "C" || temp == "X" ) && charnum == 0 ) {
							charnum++;
							front = temp;
							temp.clear();
						}
						
						else if ( charnum == 1 )
							charnum = 0;
					}
					
					if ( temp.size() == 0 && charnum == 0 ) { // 空字串 
						status = Other;	
					}

					GetToken( temp, line, status, nextChar );
					if ( charnum == 1 && front == "C" )
						status = String;
					else if ( charnum == 1 && front == "X" ) {	
						status = Hex;
					}
				}
				
				else if ( status != Remark ) { // 紀錄不是註解後的字元 
					temp = temp + nextChar;
				}
				
				if ( cut_type != Newline ) { // 紀錄原始程式碼當字元類型不是換行 
					sourceOfLine.str = sourceOfLine.str + nextChar;
				}
				
				else { // 遇到換行，新增一行原始程式碼
					line++;
					charnum = 0;
					source.push_back(sourceOfLine);
					sourceOfLine.str.clear();
					status = Other;
				}
			}
			
			file.close();
			
			// 最後可能沒有碰到換行，處理最後一行程式碼以及最後一個詞塊 //  
			if ( sourceOfLine.str.size() != 0 ) {
				source.push_back(sourceOfLine);
				sourceOfLine.str.clear();
			}
			
			if ( temp.size() != 0 ) {
				Push_in_token_record( temp,line, status );	
			}
			
			// 最後可能沒有碰到換行，處理最後一行程式碼以及最後一個詞塊 //
			
			return true;
		}
		
		else {
			return false;
		}
	}
	
	void Assign_Address() { // 算出每個指令的地址
		int line = 1;
		for ( int x = 0 ; x < source.size() ; x++ ) {
			int tokennum = 1;
			for ( int j = 0 ; j < token_record.size() && 
			      !table.Compare_Instr(token_record[j].str,"END") ; j++ ) {
				if ( x == token_record[j].line && source[x].str.size() != 0 ) {
					if ( token_record[j].str == "." && tokennum == 1 ) {
						break;
					}
					
					else if ( source[x].address == "-1" ) {
						string adr = convert.itos(pc);
						if ( adr == "0" ) {
							adr = "0000";
						}
						source[x].address = adr;
					}
					
					if ( token_record[j].numOftable == 5 && tokennum == 1 ) {
						string adr = convert.itos(pc);
						if ( !table.Exist_In_sym_table(token_record[j].str) ) {
							  table.Set_sym_table(token_record[j].valueOftable,
							                      adr,
												  token_record[j].str);
						}
						
						else {
							cout << "重複標籤!!!" << endl << endl;
							break; 
						}
					}
					
					else if ( table.Compare_Instr(token_record[j].str,"START") ) {
						if ( token_record[j+1].numOftable == 6 &&
						     token_record[j+1].line == x ) {
							int num = convert.Convert_Dec(token_record[j+1].str);
							pc = pc + num;
							for ( int i = x ; i < source.size() ; i++ ) {
								if ( i <= token_record[j].line ) {
									int newadr = atoi(source[i].address.c_str());
									newadr = newadr + pc;
									source[i].address = convert.itos(newadr);
								}
								
								else {
									break;
								}
							}
							
							table.Relocation(pc);
							j++; 
						}
					}
					
					else if ( table.Compare_Instr(token_record[j].str,"WORD") ||
					          token_record[j].numOftable == 1 ) {
						pc = pc + 3;
					}
					
					else if ( table.Compare_Instr(token_record[j].str,"RESW") ) {
						if ( token_record[j+1].numOftable == 6 && 
						     token_record[j+1].line == x ) {
							int num = atoi(token_record[j+1].str.c_str());
							num = num * 3;
							pc = pc + num;
							j++;
						}
					}
					
					else if ( table.Compare_Instr(token_record[j].str,"RESB") ) {
						if ( token_record[j+1].numOftable == 6 &&
						     token_record[j+1].line == x ) {
							int num = atoi(token_record[j+1].str.c_str());
							pc = pc + num;
							j++;
						}				
					}
					
					else if ( table.Compare_Instr(token_record[j].str,"BYTE") ) {
						if ( token_record[j+2].numOftable == 7 &&
						     token_record[j+2].line == x ) {
							int length = token_record[j+2].str.size();
							pc = pc + length;
							j = j + 2;
						}
						
						else if ( token_record[j+2].numOftable == 6 &&
						          token_record[j+2].line == x ) {
							int length = token_record[j+2].str.size() / 2;
							pc = pc + length;
							j = j + 2;
						} 
					}
					
					tokennum++;
					
				}
				
				else if ( x < token_record[j].line ) {
					break;
				}
				
				else if ( source[x].str.size() == 0 ) {
					break;
				}
			}
		}
		 
	}
	
	void Generate_Machine_Code() {
		table.Bulid_opcode_table();
		for ( int i = 0 ; i < source.size() ; i++ ) {
			int tokennum = 1;
			for ( int j = 0 ; j < token_record.size() ; j++ ) {
				if ( i == token_record[j].line ) {
					if ( table.Compare_Instr(token_record[j].str,"START") || 
					     table.Compare_Instr(token_record[j].str,"RESW") || 
						 table.Compare_Instr(token_record[j].str,"RESB") ||
						 table.Compare_Instr(token_record[j].str,"END") ) {
						break;
					}
					
					else if ( tokennum == 1 && token_record[j].str == "." ) {
						break;
					}
					
					else if ( token_record[j].numOftable == 1 ) {
						string x = "-1",adr_s = "0000", opcode;
						int g = 0;
						opcode = table.Get_opcode(token_record[j].str);
						for ( g = j+1 ; token_record[g].line == i ; g++ ) {
							if ( table.Compare_Instr(token_record[g].str,"X") ) {
								x = "1";
							}
							
							else if ( token_record[g].numOftable == 5 ) {
								adr_s = table.Get_Address(token_record[g].str);
							}
						}
						
						j = g--;
						source[i].machine_code = Get_Machine_Code( opcode, x, adr_s);
					}
					
					else if ( table.Compare_Instr(token_record[j].str,"WORD") ) {
						string x = "-1",adr_s = "0000", opcode = "00";
						int g = 0;
						for ( g = j+1; token_record[g].line == i ; g++ ) {
							if ( token_record[g].numOftable == 6 ) {
								adr_s = token_record[g].str;
								source[i].machine_code = Get_Machine_Code( opcode, x, adr_s);
							}
						}
						
						j = g--;
					}
					
					else if ( table.Compare_Instr(token_record[j].str,"BYTE") ) {
						if ( token_record[j+2].numOftable == 7 ) {
							string temp;
							for ( int g = 0 ; g < token_record[j+2].str.size() ; g++ ) {
								char ch = token_record[j+2].str[g];
								string ch2 = convert.itoc_format(16,ch);
								temp = temp + ch2;
							}
							
							source[i].machine_code = temp;
							j = j + 2;
						}
						
						else if ( token_record[j+2].numOftable == 6 ) {
							source[i].machine_code = token_record[j+2].str;
							j = j + 2;
						}
					}
					
					tokennum++;
				}
				
				else if ( i < token_record[j].line ) {
					break;
				}

				else if ( source[i].str.size() == 0 ) {
					break;
				}
			}
		}
	}
	
	void Out_File() {
		string out_name;
		// 取得標準檔案名稱 //  
		for ( int i = 0 ; i < filename.size() ; i++ ) {
			if ( filename[i] != '.' ) {
				out_name = out_name + filename[i];
			}
			
			else {
				break;
			}
		}
		
		out_name = out_name + "_output.txt";
		// 取得標準檔案名稱 //  
		file.open( out_name.c_str(), ios::out );
		int line = 5;
		file << "Line\tLoc\tSource statement\t\tObject code\n";
		for ( int i = 0 ; i < source.size() ; i++ ) {
			if ( source[i].str.size() != 0 ) {
				if ( line < 10 ) {
					file << "  ";
				}
				
				else if ( line < 100 ) {
					file << " ";
				}
				
				file << line << "\t";
				if ( source[i].address != "-1" ) {
					file << convert.itos_format(16,source[i].address) << "\t";
				}
				
				else {
					file << "\t";
				}
				
				file << source[i].str;
				int tokennum = 0;
				for ( int j = 0 ; j < token_record.size() ; j++ ) {
					if ( token_record[j].line == i ) {
						tokennum++;
					}
				}
				
				if ( tokennum < 2 ) {
					file << "\t";
				}
				
				if ( source[i].machine_code != "-1" ) {
					string str = source[i].machine_code;
					transform(str.begin(), str.end(), str.begin(), ::toupper);
					if ( source[i].str.find_first_of("\t") == 0 && tokennum > 3 ) {
						file << "\t" << str;
					}
					else				
						file << "\t\t" << str;
				}
				
				line = line + 5;
			}
			
			file << endl;
		}
		
		cout << endl << out_name << " 已經輸出!!!\n" << endl; 
		file.close();
	}
	
	void Clear() { // 初始化 
		table.Clear();
		for ( int i = 0 ; i < source.size() ; i++ ) {
			source[i].str.clear();
			source[i].address.clear();
			source[i].machine_code.clear();
		}
		
		source.clear();
		token_record.clear();
	}
	
};

int main(void) {
	Assembler assembler;
	Table table;
	while ( true ) {
		cout << "檔案名稱[0.離開]:";
		string name ;
		cin >> name ;
		if ( name != "0" ) {
			assembler.Setfilename(name);
			if ( !assembler.Lexical_Analysis(name) ) {
				cout << endl << name << " 不存在!!!\n" << endl;
			}
			
			else {
				assembler.Assign_Address();
				assembler.Generate_Machine_Code();
				assembler.Out_File();
				assembler.Clear();
			}
		}
		
		else {
			break;
		}
	}
	
	cout << "\n程式結束!!!\n";
}
