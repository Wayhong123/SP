# include<fstream>
# include<string.h>
# include<iostream>
# include<cstdlib>
# include<cstring>
# include<cctype>
# include<algorithm>
# include<sstream>
# include<vector>
# include<iomanip>
using namespace std;

typedef enum { Space = -1, Remark, Special, String, Other, Newline, Number,Hex
} CutType; // 字元的類型 

class Cutter {
public:
	CutType Cut( char ch ) { // 回傳字元的類型 
		if ( ( ch == 32 || ch == 9 || ch == 10 ) ) {
			if ( ch == 10 ) {
				return Newline;
			}
			
			return Space;
		}
		
		else if ( ch == 35 || ch == 39 || ( ch >= 42 && ch <= 47) ||
		          ch == 58 || ch == 59 || ch == 61 || ch == 63 || ch == 64 ) {
			
			if ( ch == 46 ) {
				return Remark;	
			}
			
			else {
				return Special;
			}
		}
		
		else if ( ch >= 48 & ch <= 57 ) {
			return Number;
		}
		
		else {
			return Other;
		}		
	}
};

class Table {
private:
	fstream file;
	Cutter cutter;
	vector< vector<string> > base_table; // Table1~Table4 
	typedef struct tb {
		string str; // 名稱 
		int value; //  位置 
	}table;
	
	typedef struct symTb {
		string str; // 名稱
		int value;
		int address; // 地址
	}symbolTb;
	
	typedef struct op {
		string str; // 名稱 
		string opcode;
	}opTb;
	
	struct ascending { // 升序
    	inline bool operator() (const table& struct1, const table& struct2) {
     		return (struct1.value < struct2.value);
    	}
	};
	
	vector<table> num_table; // 數字表格
	vector<symbolTb>sym_table; // 標籤表格含地址 
	vector<table> symbol_table; // 標籤表格 
	vector<table> string_table;  // 字串表格
	vector<op> opcode_table; // OPTAB
public:
	void Bulid_base_table() { // 建立表格 
		stringstream ss;
		for ( int i = 1 ; i <= 4 ; i++ ) {
			ss << i;
			string num = ss.str();
			string filename = "Table" + num + ".table";
			file.open( filename.c_str(), ios::in );
			if ( !file.fail() ) {
				string line;
				vector<string> record;
				while ( !file.eof() && getline( file, line ) ) {
					line.erase(line.find_last_not_of(' ')+1);
					record.push_back( line );
				}
				
				base_table.push_back( record );
				record.clear();
				file.close();
				ss.str("");
				ss.clear();
			}
			
			else {
				cout << filename << " 不存在!!!";
			} 
		}
	}
	
	void Bulid_opcode_table() {
		string name = "OPTABLE.txt";
		file.open(name.c_str(), ios::in );
		if ( file.fail() ) {
			cout << "OPTABLE.txt讀入失敗!!!" << endl << endl;
		}
		
		else {
			char nextChar = '\0';
			string temp;
			opTb findOP;
			while ( file.get(nextChar) ) {
				if ( nextChar != '\n'&& nextChar != ' ' ) {
					temp = temp + nextChar;
				}
				
				else if ( nextChar == '\n' ) {
					findOP.opcode = temp;
					temp.clear();
					opcode_table.push_back(findOP);
				}
				
				else if ( nextChar == ' ') {
					findOP.str = temp;
					temp.clear();
				}
			}
		}
	}
	
	bool Exist_In_sym_table( string str ) { // 重複標籤 
		for ( int i = 0 ; i < sym_table.size() ; i++ ) {
			if ( Compare_Instr( sym_table[i].str, str) ) {
				return true;
			}
		}
		
		return false;
	}
	
	void Set_sym_table( int valueOfTable, int address, string str ) {
		symTb temp;
		temp.str = str;
		temp.address = address;
		temp.value = valueOfTable;
		if ( sym_table.size() == 0 ) {
			sym_table.push_back(temp);
		}
		
		else {
			for ( int i = 0 ; i < sym_table.size() ; i++ ) {
				if ( sym_table[i].value == temp.value ) {
					temp.value++;
					if ( temp.value > 99 ) {
						temp.value = 0;
						i = -1;
					}
				}
			}
			
			sym_table.push_back(temp);
		}
	}
	
	void Relocation( int pc ) {
		for ( int i = 0 ; i < sym_table.size() ; i++ ) {
			if ( sym_table[i].str.size() != 0 ) {
				sym_table[i].address = sym_table[i].address + pc;
			}
			
			else {
				break;
			}
		}	
	}
	
	bool Compare_Instr( string str, string str2 ) { // 比較是否為相同指令 
		for ( int i = 0 ; i < str.size() ; i++ ) {
			if ( str[i] >= 65 && str[i] <= 90 ) {
				str[i] = str[i] + 32;
			}
		}
		
		for ( int i = 0 ; i < str2.size() ; i++ ) {
			if ( str2[i] >= 65 && str2[i] <= 90 ) {
				str2[i] = str2[i] + 32;
			}
		}
		
		if ( str == str2 ) {
			return true;
		}
		
		else {
			return false;
		}
	}
	
	// 將詞塊放到表格上，可能發生衝突  
	void SetInTable( int & num, vector<table> & goal, string find ) {
		if ( goal.size() != 0 ) {
			for ( int i = 0 ; i < goal.size() ; i++ ) {
				if ( find == goal[i].str ) { // 找到對應的詞塊 
					break;
				}
				
				else if ( num == goal[i].value ) { // 發生衝突 
					num++;
					if ( num > 99 ) { // 超出範圍，從表格開頭開始找起 
						num = 0;
						i = -1;
					}
				}
			}
		}
		
		table t;
		t.str = find;
		t.value = num;
		goal.push_back( t );
		sort( goal.begin(), goal.end(), ascending() ); // 表格排序 
	}
	
	// 找到詞塊對應表格的位置 
	void Find_Token( string goal, int & numOftable, int & valueOftable, CutType status ) {
		bool iSfind = false;
		// 先從Table1~Table4開始尋找對應的詞塊 //
		if ( status != String && status != Hex ) {
			for ( int i = 0 ; i < base_table.size() && !iSfind ; i++ ) {
				for ( int j = 0 ; j < base_table[i].size() ; j++ ) {
					if ( Compare_Instr( goal, base_table[i][j] ) ) {
						numOftable = i+1;
						valueOftable = j+1;
						iSfind = true;
						break;
					}
				}
			}
		}
		
		if ( !iSfind ) {  // 詞塊不在Table1~Table4 
			int  total = 0;
			for ( int i = 0 ; i < goal.size() ; i++ ) {
				total = total + goal[i];
			}
			
			total = total % 100;
			CutType cutType = cutter.Cut( goal[0] ); // 取得詞塊第一個字元的類型 
			if ( ( cutType == Number || status == Hex ) && status != String ) { // 數字 
				SetInTable( total, num_table, goal );
				numOftable = 6;
			}
			
			else if ( status == String ) { // 字串 
				SetInTable( total, string_table, goal );
				numOftable = 7;
			}
			
			else { // 標籤 
				SetInTable( total, symbol_table, goal );
				numOftable = 5;
			}
			
			valueOftable = total;
		}
	}
	 
	void Clear() { // 初始化 
		for ( int i = 0 ; i < base_table.size() ; i++ ) {
			for ( int j = 0 ; j < base_table[i].size() ; j++ ) {
				base_table[j].clear(); 
			}
			
			base_table[i].clear();
		}
		
		base_table.clear();
		num_table.clear();		
		symbol_table.clear();		
		string_table.clear();		
		
	}
	
};

class Assembler {
private:
	
	typedef struct tR {
		string str; // 名稱 
		int numOftable; // 所在的表格 
		int valueOftable; // 所在的表格位置 
		int line; // column in sourcecode 
	}tokenRecord;
	
	typedef struct sR {
		string str; // 原始程式碼 
		int address; // 地址 
		int machine_code; // 機器碼 
	}sourceRecord;
	
	fstream file;
	string filename;
	int pc; // 程式計數器 
	Cutter cutter; // 字元處理
	Table table; // 表格
	vector<sourceRecord> source; // 原始程式碼
	vector<tokenRecord> token_record; // 紀錄詞塊
	
public:
	
	Assembler() {
		pc = 0;
	}
	
	void Setfilename( string name ) { // 檔案名稱 
		filename = name;	
	}
	
	int Convert_Hex( string str ) { // 轉換成10進位 
		int num;
		istringstream( str ) >> hex >> num;
		return num;
	}
	
	// 紀錄新的詞塊 // 
	void Push_in_token_record( string & temp, int line, CutType status ) {  
		tokenRecord token;
		token.str = temp;
		token.line = line;
		table.Find_Token(temp,token.numOftable,token.valueOftable,status);
		token_record.push_back(token);
		temp.clear();
	}
	
	// 紀錄一個或兩個詞塊 // 
	void GetToken( string & temp, int line, CutType & status, char nextChar ) {
		if ( temp.size() == 0 ) { // 一個詞塊
			temp = temp + nextChar;
			Push_in_token_record( temp,line, status );
		}
		
		else { // 兩個詞塊
			Push_in_token_record( temp,line, status );
			temp = temp + nextChar;
			if ( status == String || status == Hex ) {
				status = Other;	
			}
			Push_in_token_record( temp,line, status );
		}
	}
	
	bool Lexical_Analysis( string filename ) { // 語彙分析 
		file.open(filename.c_str(), ios::in );
		if ( !file.fail() ) {
			char nextChar = '\0';
			string temp;
			sourceRecord sourceOfLine;
			sourceOfLine.address = -1;
			sourceOfLine.machine_code = 0;
			table.Bulid_base_table();
			int charnum = 0,line = 0;
			CutType status = Other;
			while ( file.get(nextChar) ) {
				CutType cut_type = cutter.Cut( nextChar );
				// 空格或換行
				if ( ( cut_type == Space || cut_type == Newline ) && ( status == Other )) {
					if ( temp.size() != 0 ) {
						Push_in_token_record( temp,line, status );
					}
				}
				
				else if ( cut_type == Remark && status == Other ) { // 註解 
					GetToken( temp, line, status, nextChar );
					status = Remark;
				}
				
				// 特殊符號 && 字串 && 十六進位 
				else if ( ( cut_type == Special && status == Other) ||
						  ( nextChar == 39 && charnum == 1 ) ) {
					string front;
					if ( nextChar == 39 ) {
						if ( ( temp == "C" || temp == "X" ) && charnum == 0 ) {
							charnum++;
							front = temp;
							temp.clear();
						}
						
						else if ( charnum == 1 )
							charnum = 0;
					}
					
					if ( temp.size() == 0 && charnum == 0 ) { // 空字串 
						status = Other;	
					}
					
					GetToken( temp, line, status, nextChar );
					if ( charnum == 1 && front == "C" )
						status = String;
					else if ( charnum == 1 && front == "X" )
						status = Hex; 
				}
				
				else if ( status != Remark ) { // 紀錄不是註解後的字元 
					temp = temp + nextChar;
				}
				
				if ( cut_type != Newline ) { // 紀錄原始程式碼當字元類型不是換行 
					sourceOfLine.str = sourceOfLine.str + nextChar;
				}
				
				else { // 遇到換行，新增一行原始程式碼
					line++;
					charnum = 0;
					source.push_back(sourceOfLine);
					sourceOfLine.str.clear();
					status = Other;
				}
			}
			
			file.close();
			
			// 最後可能沒有碰到換行，處理最後一行程式碼以及最後一個詞塊 //  
			if ( sourceOfLine.str.size() != 0 ) {
				source.push_back(sourceOfLine);
				sourceOfLine.str.clear();
			}
			
			if ( temp.size() != 0 ) {
				Push_in_token_record( temp,line, status );	
			}
			
			// 最後可能沒有碰到換行，處理最後一行程式碼以及最後一個詞塊 //
			
			return true;
		}
		
		else {
			return false;
		}
	}
	
	void Assign_Address() { // 算出每個指令的地址
		int line = 1;
		for ( int x = 0 ; x < source.size() ; x++ ) {
			int tokennum = 1;
			for ( int j = 0 ; j < token_record.size() ; j++ ) {
				if ( x == token_record[j].line && source[x].str.size() != 0 ) {
					source[x].address = pc;
					if ( token_record[j].numOftable == 5 && tokennum == 1 ) {
						if ( !table.Exist_In_sym_table(token_record[j].str) ) {
							  table.Set_sym_table(token_record[j].valueOftable,
							                      pc,
												  token_record[j].str);
						}
						
						else {
							cout << "重複標籤!!!" << endl << endl;
							break; 
						}
					}
					
					else if ( table.Compare_Instr(token_record[j].str,"START") ) {
						if ( token_record[j+1].numOftable == 6 ) {
							int num = Convert_Hex(token_record[j+1].str);
							pc = pc + num;
							for ( int i = x ; i < source.size() ; i++ ) {
								if ( i <= token_record[j].line ) {
									source[i].address = source[i].address + num;
								}
								
								else {
									break;
								}
							}
							
							table.Relocation(num);
							j++; 
						}
					}
					
					else if ( table.Compare_Instr(token_record[j].str,"WORD")) {
						pc = pc + 3;
					}
					
					else if ( table.Compare_Instr(token_record[j].str,"RESW") ) {
						if ( token_record[j+1].numOftable == 5 ) {
							int num = Convert_Hex(token_record[j+1].str);
							num = num * 3;
							pc = pc + num;
							j++;
						} 
					}
					
					else if ( table.Compare_Instr(token_record[j].str,"RESB") ) {
						if ( token_record[j+1].numOftable == 5 ) {
							int num = Convert_Hex(token_record[j+1].str);
							pc = pc + num;
							j++;
						}				
					}
					
					else if ( table.Compare_Instr(token_record[j].str,"BYTE") ) {
						if ( token_record[j+2].numOftable = 7 ) {
							int length = token_record[j+2].str.size();
							pc = pc + length;
							j = j + 2;
						}
					}
					
					else if ( token_record[j].numOftable == 1 ) {
						pc = pc + 3;
					}
					
					tokennum++;
					
				}
				
				else if ( x < token_record[j].line ) {
					if ( source[x].str.size() != 0 )
						cout << hex << source[x].address << endl;
					break;
				}
				
				else if ( source[x].str.size() == 0 ) {
					break;
				}
			}
		}
	}
	/*
	void Out_File() {
		string out_name;
		// 取得標準檔案名稱 //  
		for ( int i = 0 ; i < filename.size() ; i++ ) {
			if ( filename[i] != '.' ) {
				out_name = out_name + filename[i];
			}
			
			else {
				break;
			}
		}
		
		out_name = out_name + "_output.txt";
		// 取得標準檔案名稱 //  
		file.open( out_name.c_str(), ios::out );
		for ( int i = 0 ; i < source.size() ; i++ ) {
			file << source[i] << endl;
			for ( int j = 0 ; j < token_record.size() ; j++ ) {
				if ( token_record[j].line == i ) {
					file << "(" << token_record[j].numOftable << ","
						 << token_record[j].valueOftable << ")";
				}
				
				else if ( token_record[j].line > i ) {
					file << endl; 
					break;
				}
			}
		}
		
		cout << endl <<out_name << " 已經輸出!!!\n" << endl; 
		file << endl;
		file.close();
	}
	*/
	void Clear() { // 初始化 
		table.Clear();
		for ( int i = 0 ; i < source.size() ; i++ ) {
			source[i].str.clear();
			source[i].address = 0;
			source[i].machine_code = 0;
		}
		
		source.clear();
		token_record.clear();
				
	}
	
};

int main(void) {
	Assembler assembler;
	Table table;
	while ( true ) {
		cout << "檔案名稱[0.離開]:";
		string name ;
		cin >> name ;
		if ( name != "0" ) {
			assembler.Setfilename(name);
			if ( !assembler.Lexical_Analysis(name) ) {
				cout << endl << name << " 不存在!!!\n" << endl;
			}
			
			else {
				assembler.Assign_Address();
				//assembler.Out_File();
				assembler.Clear();
			}
		}
		
		else {
			break;
		}
	}
	
	cout << "\n程式結束!!!\n";
}
